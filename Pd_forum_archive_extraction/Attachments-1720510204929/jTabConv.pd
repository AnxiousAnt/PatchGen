#N canvas 88 40 1219 776 10;
#X declare -lib iem_tab;
#X obj 399 27 inlet;
#X obj 812 34 t b b;
#X obj 812 96 +;
#X obj 812 118 - 1;
#N canvas 0 22 450 300 powerOf2GreaterThan 0;
#X obj 92 73 jLog 2;
#X obj 92 104 int;
#X obj 92 126 + 1;
#X obj 92 158 swap 2;
#X obj 92 180 pow;
#X obj 92 35 inlet;
#X obj 92 225 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 3 1 4 1;
#X connect 4 0 6 0;
#X connect 5 0 0 0;
#X restore 812 194 pd powerOf2GreaterThan;
#X floatatom 902 243 15 0 0 0 - - -;
#X text 926 61 get array lengths;
#X text 961 194 calc blocksize = nearest ^2 > size y;
#X obj 812 140 t f f;
#X obj 396 314 tabwrite~ \$0-X-re;
#X obj 406 334 tabwrite~ \$0-X-im;
#X obj 399 193 t b b;
#X obj 529 193 t b b;
#X obj 526 314 tabwrite~ \$0-H-re;
#X obj 536 334 tabwrite~ \$0-H-im;
#X obj 426 272 rfft~;
#X obj 556 272 rfft~;
#X obj 397 411 tab_complex_mul \$0-X-re \$0-X-im \$0-H-re \$0-H-im
\$0-XH-re \$0-XH-im;
#X obj 424 592 rifft~;
#X obj 397 503 t b b b;
#X obj 424 532 tabplay~ \$0-XH-re;
#X obj 457 572 tabplay~ \$0-XH-im;
#X obj 399 121 t b b;
#X obj 426 232 tabplay~ \$1;
#X obj 556 232 tabplay~ \$2;
#X obj 397 674 tabwrite~ \$3;
#X obj 424 637 /~;
#X obj 439 614 r \$0-blocksize;
#X obj 902 261 s \$0-blocksize;
#X obj 1045 233 pack f \$0;
#X msg 1045 255 \; \$2-X-re resize \$1 \; \$2-X-im resize \$1 \; \$2-H-re
resize \$1 \; \$2-H-im resize \$1 \; \$2-XH-re resize \$1 \; \$2-XH-im
resize \$1 \;;
#X text 1042 352 resize calculation arrays;
#X text 454 633 ifft~ gain normalisation \; / by blocksize;
#X text 421 387 complex multiply tables X by H;
#X text 483 500 inverse fft~;
#X text 484 147 perform fft~;
#X obj 447 29 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 736 245 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X obj 399 49 t b b b;
#X msg 1070 648 \; \$2-X-re resize 1 \; \$2-X-im resize 1 \; \$2-H-re
resize 1 \; \$2-H-im resize 1 \; \$2-XH-re resize 1 \; \$2-XH-im resize
1 \;;
#X obj 1070 606 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 1070 626 pack f \$0;
#X text 809 339 run patch at 2048 speed!;
#X text 678 214 switch~ off after computation;
#X obj 523 721 outlet;
#X obj 523 551 t b b;
#X text 567 721 bang on finish;
#X text 1067 572 resize arrays to 1 before patch save;
#N canvas 0 22 646 483 arrayTablesAreInHere 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-X-re 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 11 85 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-X-im 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 11 245 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-H-re 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 221 85 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-H-im 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 221 245 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-XH-re 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 431 85 graph;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-XH-im 131072 float 2;
#X coords 0 1 131072 -1 200 140 1 0 0;
#X restore 431 245 graph;
#X restore 775 557 pd arrayTablesAreInHere;
#X obj 812 321 switch~;
#X text 863 120 calc and set dest array \; size y = size x + size h
- 1;
#X msg 812 300 set \$1 1 2048;
#X obj 39 643 loadbang;
#X msg 39 665 \; pd dsp 1;
#X obj 812 54 jArraySize \$1;
#X obj 822 74 jArraySize \$2;
#X obj 839 162 jArraySize \$3;
#X obj 39 714 import iem_tab;
#X text 9 10 Convolve two tables by multiplication in the frequency
domain using FFT. \; \; \$1 Table 1 (referred to here as 'x') \; \$2
Table 2 (referred to here as 'h') \; \$3 Output table (referred to
as 'y' or 'XH') \; \; in1 bang to convolve tables \; out2 bang when
done \; \; The FFT method works very quickly for long tables. In comparison
\, on this machine \, for 1 second tables at 44.1k iem_tab tab_conv
(presumably time domain) takes >10 seconds whereas this method takes
a few milliseconds. The speed of computation is governed by switch~'s
oversampling rate (on this machine 2048 seems to be optimal). \; \;
There is some error when comparing to iem_tab tab_conv which presumably
is down to number precision error going back and forth through fft~/ifft~
(specifically gain from ifft~ at huge blocksize which needs to be normalised).
This may be unacceptable for some applications e.g. filtering but acceptable
for reverb or special effects. \; \; Requires: \; jLibrary [jArraySize]
\; jLibrary [jLog] \; iem_tab [tab_complex_mul] \; \; TO DO: \; - Try
to eliminate/reduce error? \; - switch~ only required elements \; -
vanilla complex multiply (tried \, iem_tab way faster) \; \; John Flynn
;
#X connect 0 0 38 0;
#X connect 1 0 54 0;
#X connect 1 1 55 0;
#X connect 2 0 3 0;
#X connect 3 0 8 0;
#X connect 4 0 5 0;
#X connect 4 0 28 0;
#X connect 4 0 29 0;
#X connect 4 0 51 0;
#X connect 8 0 4 0;
#X connect 8 1 56 0;
#X connect 11 0 9 0;
#X connect 11 0 10 0;
#X connect 11 1 23 0;
#X connect 12 0 13 0;
#X connect 12 0 14 0;
#X connect 12 1 24 0;
#X connect 15 0 9 0;
#X connect 15 1 10 0;
#X connect 16 0 13 0;
#X connect 16 1 14 0;
#X connect 17 0 19 0;
#X connect 18 0 26 0;
#X connect 19 0 25 0;
#X connect 19 1 20 0;
#X connect 19 2 21 0;
#X connect 20 0 18 0;
#X connect 20 1 45 0;
#X connect 21 0 18 1;
#X connect 22 0 11 0;
#X connect 22 1 12 0;
#X connect 23 0 15 0;
#X connect 23 1 17 0;
#X connect 24 0 16 0;
#X connect 26 0 25 0;
#X connect 27 0 26 1;
#X connect 29 0 30 0;
#X connect 36 0 38 0;
#X connect 37 0 49 0;
#X connect 38 0 22 0;
#X connect 38 1 1 0;
#X connect 38 2 37 0;
#X connect 40 0 41 0;
#X connect 41 0 39 0;
#X connect 45 0 44 0;
#X connect 45 1 37 0;
#X connect 51 0 49 0;
#X connect 52 0 53 0;
#X connect 54 0 2 0;
#X connect 55 0 2 1;
