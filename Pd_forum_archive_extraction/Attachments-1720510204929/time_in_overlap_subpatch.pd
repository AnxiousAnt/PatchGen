#N canvas 301 18 420 523 10;
#N canvas 831 362 253 296 testsignal 0;
#X obj 13 32 osc~ 7000;
#X obj 97 33 loadbang;
#X obj 97 56 1;
#X obj 12 172 *~;
#X obj 97 135 line~;
#X msg 62 11 0.25;
#X msg 97 105 1 \, 0 3;
#X obj 148 262 outlet;
#X obj 12 197 outlet~;
#X obj 97 81 metro 2000;
#X obj 148 198 env~;
#X obj 148 241 sel 1;
#X obj 148 221 > 80;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 9 0;
#X connect 3 0 8 0;
#X connect 3 0 10 0;
#X connect 4 0 3 1;
#X connect 5 0 0 1;
#X connect 6 0 4 0;
#X connect 9 0 6 0;
#X connect 9 0 5 0;
#X connect 10 0 12 0;
#X connect 11 0 7 0;
#X connect 12 0 11 0;
#X restore 25 17 pd testsignal;
#X obj 24 187 env~;
#X obj 24 230 sel 1;
#N canvas 0 110 412 416 hann-window 0;
#N canvas 0 0 450 300 graph1 0;
#X array \$0-hann 1024 float 0;
#X coords 0 1 1023 0 300 100 1;
#X restore 36 253 graph;
#X obj 288 130 osc~;
#X obj 288 155 *~ -0.5;
#X obj 288 179 +~ 0.5;
#X obj 241 212 tabwrite~ \$0-hann;
#X obj 26 118 samplerate~;
#X obj 26 142 /;
#X msg 161 71 resize \$1;
#X obj 161 95 s \$0-hann;
#X msg 292 95 0;
#X obj 240 96 t f b;
#X obj 26 67 r \$0-window-size;
#X obj 26 166 s \$0-window-hz;
#X obj 240 70 r \$0-window-hz;
#X obj 26 94 t b f f;
#X text 22 8 calculate Hann window table (variable window size) and
constants window-hz (fundamental frequency of analysis).;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 5 0 6 0;
#X connect 6 0 12 0;
#X connect 7 0 8 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 10 1 4 0;
#X connect 10 1 9 0;
#X connect 11 0 14 0;
#X connect 13 0 10 0;
#X connect 14 0 5 0;
#X connect 14 1 6 1;
#X connect 14 2 7 0;
#X restore 238 149 pd hann-window;
#X obj 291 61 s \$0-window-size;
#X obj 291 39 1024;
#X obj 291 18 loadbang;
#X floatatom 23 100 5 0 480 0 - - -;
#X obj 23 119 sig~;
#X msg 158 104 1;
#X msg 184 104 2;
#X msg 213 104 4;
#X obj 97 268 timer;
#X floatatom 150 296 9 0 0 0 - - -;
#X obj 24 209 > 60;
#X text 247 103 set overlap (init = 1);
#X obj 24 69 delwrite~ delayline 2000;
#X obj 97 314 / 1;
#X obj 179 135 f;
#X floatatom 153 343 5 0 0 0 - - -;
#X text 220 297 measured delay time;
#X text 197 341 divided by overlap factor;
#X text 61 100 set delay (ms);
#N canvas 612 291 395 225 subpatch_with_overlap 0;
#X obj 14 76 vd~ delayline;
#X obj 13 40 inlet~;
#X obj 13 159 outlet~;
#X obj 171 169 block~;
#X obj 221 48 inlet;
#X text 266 47 overlap factor;
#X obj 28 110 tabreceive~ \$0-hann;
#X obj 14 133 *~;
#X obj 171 26 r \$0-window-size;
#X msg 171 145 set \$1 \$2;
#X obj 221 73 t b f;
#X obj 171 121 pack f 1;
#X connect 0 0 7 0;
#X connect 1 0 0 0;
#X connect 4 0 10 0;
#X connect 6 0 7 1;
#X connect 7 0 2 0;
#X connect 8 0 11 0;
#X connect 9 0 3 0;
#X connect 10 0 11 0;
#X connect 10 1 11 1;
#X connect 11 0 9 0;
#X restore 23 143 pd subpatch_with_overlap;
#X text 17 385 this patch demonstrates \, that a delay time of a [vd~]
or [delread~] has to be divided by the overlap factor in order to get
the desired delay.;
#X connect 0 0 16 0;
#X connect 0 1 12 0;
#X connect 1 0 14 0;
#X connect 2 0 12 1;
#X connect 5 0 4 0;
#X connect 6 0 5 0;
#X connect 7 0 8 0;
#X connect 8 0 23 0;
#X connect 9 0 18 0;
#X connect 10 0 18 0;
#X connect 11 0 18 0;
#X connect 12 0 13 0;
#X connect 13 0 17 0;
#X connect 14 0 2 0;
#X connect 17 0 19 0;
#X connect 18 0 17 1;
#X connect 18 0 23 1;
#X connect 23 0 1 0;
